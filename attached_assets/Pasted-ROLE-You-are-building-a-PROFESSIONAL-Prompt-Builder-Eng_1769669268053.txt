ROLE: You are building a PROFESSIONAL “Prompt Builder Engine” inside the existing Digital Platform Factory (monorepo: apps/api, apps/web, apps/mobile, packages/shared). Goal: Customers can type a prompt and the platform automatically configures modules, workflows, data model templates, and dashboard UI WITHOUT running arbitrary code.

NON-NEGOTIABLE RULES
1) Proof-first: Never claim done without evidence (logs + curl outputs + screenshots paths + git diff/stat).
2) Non-breaking: Do not refactor working code. Additive changes only.
3) Security first: No raw code execution. No arbitrary file writes from user prompts. Prompt injection resistant.
4) Tenant isolation: Every build request and artifact is tenant-scoped.
5) Cost control: If AI is used, enforce quotas + caching + module flag ai_assistant must be enabled.

WHAT TO BUILD (MVP)
Build a “Build from Prompt” feature:
- Web UI page: /dashboard/builder
- API endpoints: /api/builder/*
- A Blueprint format (JSON) that represents what will be built
- A deterministic Builder that applies the blueprint by:
  a) enabling modules
  b) setting module configs
  c) creating workflow definitions
  d) creating sample data
  e) generating a “Setup Checklist” output for the tenant
- A Proof Report entry written to reports/proof.md (append section)

DO NOT BUILD
- No user-provided arbitrary code execution (no npm install from prompts, no docker sandbox)
- No creating new apps or new runtime stacks
- No database schema migrations generated from prompts in MVP
  (use templates + existing core tables + module config JSON)

CORE CONCEPTS
A) Customer prompt -> Blueprint
Blueprint is the contract. The system first produces a blueprint, shows it to the user, then builds only after confirmation.

B) Templates
Support templates that map prompt intent to module/workflow config:
Templates (v1):
- booking_business
- ecommerce_store
- clinic_appointment
- courier_delivery
- support_desk
- crm_pipeline

Each template defines:
- required modules to enable
- workflow states (JSON)
- default roles/permissions
- connector recommendations (stripe/email/storage/push)
- sample data seeds
- dashboard widgets to show

C) Guardrails
- Prompt length limit (e.g., 4k chars)
- Content filtering: reject requests to build malware, hacking tools, illegal content
- Strip secrets/PII from prompt storage
- Store prompt + blueprint + build result in DB with tenantId

DATABASE (ADD MODELS via Prisma MIGRATION)
Add these models (tenant-scoped):
- BuilderRequest:
  id, tenantId, userId, promptText, normalizedPromptHash, status (draft|approved|building|done|failed),
  createdAt, updatedAt
- Blueprint:
  id, tenantId, builderRequestId, templateKey, blueprintJson, summary, createdAt
- BuildRun:
  id, tenantId, builderRequestId, status, startedAt, finishedAt, outputJson, errorText

Rules:
- Every query includes tenantId
- Audit log entries for create/approve/build actions

API ENDPOINTS (apps/api)
1) POST /api/builder/draft
Input: { prompt: string }
Output: { builderRequestId, blueprintId, blueprint: {...}, summary: string }
Behavior:
- Normalize prompt
- If ai_assistant module enabled AND OPENAI_API_KEY present -> use AI to classify templateKey + extract entities
- Else -> use deterministic classifier (keyword rules) to select templateKey
- Produce blueprintJson using template defaults + extracted entities
- Save BuilderRequest (draft) + Blueprint
- Return blueprint for UI review

2) POST /api/builder/approve
Input: { builderRequestId }
Output: { ok: true }
Behavior:
- Mark status approved
- Write audit log: BUILDER_APPROVED

3) POST /api/builder/run
Input: { builderRequestId }
Output: { buildRunId, status }
Behavior:
- Must be approved
- Apply blueprint:
  - Enable required modules (ModuleFlag)
  - Write module configs (ModuleFlag.configJson)
  - Create workflow definitions (store inside ModuleFlag.configJson for v1)
  - Seed sample data (use existing or new minimal tables if present; otherwise store as config JSON)
  - Create “setup checklist” outputJson
- Mark BuildRun done
- Write audit logs for actions

4) GET /api/builder/requests
Output: list recent builder requests for tenant

WEB UI (apps/web)
Add “Builder” to dashboard nav.
Page: /dashboard/builder
Flow:
- Textarea prompt input
- Click “Generate Blueprint”
- Show:
  - Template selected
  - Modules to enable
  - Workflows summary
  - Connector recommendations
  - Sample data summary
- Button: “Approve & Build”
- Show build result:
  - Enabled modules
  - Checklist (what customer must configure next)
  - Links to Modules + Connectors pages

MOBILE (apps/mobile)
Optional MVP:
- Add a “Builder” tab that links to builder request list or shows “Use web dashboard to build”.
Keep minimal. Do not block publish.

SECURITY & COMPLIANCE
- Validate all inputs (Zod)
- RBAC: only owner/admin can approve/run builds
- Rate limits on builder endpoints
- Store prompt safely; do not log prompt body
- Audit logs must include builder actions
- If AI used: enforce quota + caching; redact sensitive strings

PROOF-FIRST DELIVERABLES
1) Update README.md with Builder feature
2) Update DEPLOY.md env var list if any new vars added
3) Append to reports/proof.md:
   - curl for /api/builder/draft, /approve, /run
   - show module flags changed
   - show audit log entry
   - show builder request list

MANDATORY VERIFICATION COMMANDS (RUN AND CAPTURE)
- pnpm -r typecheck
- API start log
- curl sequence:
  a) login -> get JWT
  b) draft builder prompt
  c) approve
  d) run
  e) fetch modules list and confirm enabled
  f) fetch audit logs and confirm entries

START NOW
Implement minimal safe version first:
- Template-based classifier (no AI required)
- Blueprint preview UI
- Build applies module flags + configs + checklist
Then optionally add AI template classification behind feature flag.

STOP CONDITION
Do not ask questions. Implement and provide proof outputs + file paths + minimal instructions to use the Builder in the dashboard.